---
author: "Adri√°n & Solveig"
title: "Permutation"
output: html_document
---

```{r}
# Load libraries
library(tidyverse)
```

#Plot perutation result:
For putting in to different permutation functions to be able to plot the result of the permutations nicely
```{r}
plot_permutation <- function(data, observed_value, title){
  #making dataset to put in to permutation plot
  pd <- data.frame(i=1:length(data), value=data)
    #plotting the null distribution and observed difference with the observed as a line
  plot <- ggplot(data = pd, mapping = aes(x=value)) + 
    geom_histogram(fill="darkblue", bins=50) +
    geom_vline(color="darkorange",xintercept = as.numeric(observed_value)) + 
    xlab("")+
    ylab("Count")+
    ggtitle(title, "The orange line is the observed value")+
    theme_minimal()
  return(plot)
}
```


#Permutation basics:
Mean, define number of permutaions, 10000 being default value.
Define dataset, the column name for the column with the different categories you want to compare means for and the name of the columns with the counts.
The names of the groups/categories.

### Permute mean

```{r}
permutation_mean <- function(dataset, name, count, group1, group2, no_perm=10000, nice_plot=FALSE){
  # Verify if the columns exists and if the groups exists
  if (any(names(dataset) == name) == FALSE | any(names(dataset) == count) == FALSE){
    stop("One of the columns does not exists. Please, check the spelling or the dataset you are giving") 
  } else if (any(unique(get(name,dataset)) == group1) == FALSE | any(unique(get(name,dataset)) == group2) == FALSE) {
    stop("One of the groups does not exists. Please, check the spelling or the dataset you are giving")
  }
  
  # Select columns in the dataset and remane those
  dataset <- dataset[c(count,name)]      # Select
  names(dataset) <- c("count","name")    # Rename
  
    #Check if the dataset is normally distributed, and give a warning, if it is:
  if (shapiro.test(dataset$count)$p.value>0.05){
    warning("Data is normally distributed, it might be better to use a parametric test (e.g. t-test)")
  }

  r <- rep(NA,no_perm)
  
  # Progress bar
  pb <- txtProgressBar(min = 1, max = no_perm, style = 3)
  
  for (i in 1:length(r)) {
    setTxtProgressBar(pb, i)
    #shuffle dataset
    p <- dataset
    p$count <- sample(p$count)

    #calculate mean for group 1 and group 2
    g1 <- mean(p[which(p$name == group1),]$count)
    g2 <- mean(p[which(p$name == group2),]$count)

    #add difference in mean to vector
    r[i] <- as.numeric(g1) - as.numeric(g2)
  }
  close(pb)

  # The observed difference
  m1 <- mean(dataset[which(dataset$name == group1),]$count)
  m2 <- mean(dataset[which(dataset$name == group2),]$count)
  observed <- m1-m2       # Observed mean

  estimate <- c(as.numeric(m1),as.numeric(m2),as.numeric(observed))
  names(estimate) <- c("Mean first group","Mean second group","Observed mean difference")

  # P-value
  p_value <- ((sum(abs(r) >= abs(observed))+1)/(length(r)+1))
  names(p_value) <- "p-value"

  result = list(method = "Permutation Test (Mean)", p.value = p_value,
                  estimate = estimate,
                  data.name = sprintf("Permutation for group: %s and %s", group1, group2))
  class(result) <- "htest"

  # If statement to plot or not
  if (nice_plot == TRUE) {
    # Plot + result

    plot <- plot_permutation(r, observed, "Permutation test (Mean)")

    print(result)
    return(plot)
  } else if (nice_plot == FALSE) {
    # Result
    print(result)
    hist(r, col="darkblue", breaks = 50, main = "Mean permuted distribution", ylab = "Count"); abline(v = observed, col = "darkorange")
  }
}


names <- c(replicate(50,"Something"), replicate(50, "Something_else"))
test <- data.frame(rnorm(100), names)
names(test) <- c("value","names")
permutation_mean(test, "names", "value", "Something", "Something_else", nice_plot = F)

```


### Permutation median:

```{r}
permutation_median <- function(dataset, name, count, group1, group2, no_perm=10000, nice_plot=FALSE) {
  # Verify if the columns exists and if the groups exists
  if (any(names(dataset) == name) == FALSE | any(names(dataset) == count) == FALSE){
    stop("One of the columns does not exists. Please, check the spelling or the dataset you are giving") 
  } else if (any(unique(get(name,dataset)) == group1) == FALSE | any(unique(get(name,dataset)) == group2) == FALSE) {
    stop("One of the groups does not exists. Please, check the spelling or the dataset you are giving")
  }
  
  # Select columns in the dataset and remane those
  dataset <- dataset[c(count,name)]      # Select
  names(dataset) <- c("count","name")    # Rename
  
    #Check if the dataset is normally distributed, and give a warning, if it is:
  if (shapiro.test(dataset$count)$p.value>0.05){
    warning("Data is normally distributed, it might be better to use a parametric test")
  }

  r <- rep(NA,no_perm)
  
  # Progress bar
  pb <- txtProgressBar(min = 1, max = no_perm, style = 3)
  
  for (i in 1:length(r)) {
    setTxtProgressBar(pb, i)
    #shuffle dataset
    p <- dataset
    p$count <- sample(p$count)

    #calculate median for group 1 and group 2
    g1 <- median(p[which(p$name == group1),]$count)
    g2 <- median(p[which(p$name == group2),]$count)

    #add difference in median to vector
    r[i] <- as.numeric(g1) - as.numeric(g2)
  }
  close(pb)
  
  # The observed difference
  m1 <- median(dataset[which(dataset$name == group1),]$count)
  m2 <- median(dataset[which(dataset$name == group2),]$count)
  observed <- m1-m2       # Observed median

  estimate <- c(as.numeric(m1),as.numeric(m2),as.numeric(observed))
  names(estimate) <- c("Median first group","Median second group","Observed median difference")

  # P-value
  p_value <- ((sum(abs(r) >= abs(observed))+1)/(length(r)+1))
  names(p_value) <- "p-value"

  result = list(method = "Permutation Test (Median)", p.value = p_value,
                  estimate = estimate,
                  data.name = sprintf("Permutation for group: %s and %s", group1, group2))
  class(result) <- "htest"

  # If statement to plot or not
  if (nice_plot == TRUE) {
    # Plot + result

    plot <- plot_permutation(r, observed, "Permutation test (Median")

    print(result)
    return(plot)
  } else if (nice_plot == FALSE) {
    # Result
    print(result)
    hist(r, col="darkblue", breaks = 50, main = "Median permuted distribution", ylab = "Count"); abline(v = observed, col = "darkorange")
  }
}

names <- c(replicate(50,"GROUP1"), replicate(50, "GROUP2"))
test <- as_tibble(rnorm(100)) %>% mutate(names=names)

permutation_median(test, "names", "value", "GROUP1", "GROUP2", nice_plot = T)
```


### Permutation linear model comparison

Permutation that uses the F-distribution to compare two of three linear models (linear, quadratic or cubic).
It needs a dataset and the names of the columns with the predictor and the response values and the kind of models to compare.
It will give the p-value for the more complicated model not being the better.

```{r}
permutation_lm <- function(dataset, predictor, response, model1, model2, no_perm=10000, nice_plot=F){
  # Verify if the columns exists and if the groups exists
  accepted_models <- c("linear","quadratic","cubic")
  
  if (any(names(dataset) == predictor) == FALSE | any(names(dataset) == response) == FALSE){
    stop("One of the columns does not exists. Please, check the spelling or the dataset you are giving") 
  } else if (any(accepted_models == model1) == FALSE | any(accepted_models == model2) == FALSE) {
    stop("Error: Models must be a combination of linear, quadractic or cubic.")
  }
  
  # Select columns in the dataset and remane those
  dataset <- dataset[c(predictor,response)]      # Select
  names(dataset) <- c("predictor","response")    # Rename
  
    #Check if the dataset is normally distributed, and give a warning, if it is:
  if (shapiro.test(dataset$response)$p.value>0.05){
    warning("Data is normally distributed, it might be better to use a parametric test, (e.g. anova)")
  }
  
  r <- rep(NA,no_perm)
  
  # SELECT MODEL
  if ((model1=="linear" & model2=="quadratic")|(model2=="linear" & model1=="quadratic")){    # For linear and quadratic model:
    # Observed models:
    mod1 <- lm(response ~ predictor, data=dataset)
    mod2 <- lm(response ~ poly(predictor, 2), data=dataset)
    # Progress bar
    pb <- txtProgressBar(min = 1, max = no_perm, style = 3)
    for (i in 1:length(r)) {
      setTxtProgressBar(pb, i)
      # Shuffle dataset
      p <- dataset
      p$response <- sample(p$response)
      
      # Make models
      m1 <- lm(response ~ predictor, data=p)
      m2 <- lm(response ~ poly(predictor, 2), data=p)
      
      # Make F-distribution
      f_dist <- anova(m1, m2)
      
      # Add F-values to r-vector:
      r[i] <- f_dist$`F`[2]
      
    }
    close(pb)
  } else if ((model1=="linear" & model2=="cubic")|(model2=="linear" & model1=="cubic")){    # For linear and cubic model:
    # Observed models:
    mod1 <- lm(response ~ predictor, data=dataset)
    mod2 <- lm(response ~ poly(predictor, 3), data=dataset)
    # Progress bar
    pb <- txtProgressBar(min = 1, max = no_perm, style = 3)
    for (i in 1:length(r)) {
      setTxtProgressBar(pb, i)
      # Shuffle dataset
      p <- dataset
      p$response <- sample(p$response)
      
      # Make models
      m1 <- lm(resp ~ predictor, data=p)
      m2 <- lm(resp~ poly(predictor, 3), data=p)
      
      # Make F-distribution
      f_dist <- anova(m1, m2)
      
      # Add F-values to r-vector:
      r[i] <- f_dist$`F`[2]
      
    }
    close(pb)
  } else if ((model1=="quadratic" & model2=="cubic")|(model2=="quadratic" & model1=="cubic")){    # For quadratic and cubic model:
    # Observed models:
    mod1 <- lm(response ~ poly(predictor,2), data=dataset)
    mod2 <- lm(response ~ poly(predictor, 3), data=dataset)
    # Progress bar
    pb <- txtProgressBar(min = 1, max = no_perm, style = 3)
    for (i in 1:length(r)) {
      setTxtProgressBar(pb, i)
      # Shuffle dataset
      p <- dataset
      p$response <- sample(p$response)
      
      # Make models
      m1 <- lm(response ~ poly(predictor, 2), data=p)
      m2 <- lm(response ~ poly(predictor, 3), data=p)
      
      # Make F-distribution
      f_dist <- anova(m1, m2)
      
      # Add F-values to r-vector:
      r[i] <- f_dist$`F`[2]
      
    }
    close(pb)
  }
  
  # The observed value and format
  observed <- anova(mod1, mod2)$`F`[2]
  estimate <- as.numeric(observed)
  names(estimate) <- c("Observed F value between models")

  # P-value and format
  p_value <- (sum((r) >= (observed))+1)/(length(r)+1)
  names(p_value) <- "p-value"

  # Result format
  result = list(method = sprintf("Permutation Test (ANOVA) for %s and %s models", model1, model2), p.value = p_value,
                  estimate = estimate,
                  data.name = sprintf("Permutation for predictor %s and response %s", predictor, response))
  class(result) <- "htest"

  # If statement to plot or not
  if (nice_plot == TRUE) {
    # Plot + result

    plot <- plot_permutation(r,observed, "Permutation test (Model comparison, F-test)")

    print(result)
    return(plot)
  } else if (nice_plot == FALSE) {
    # Result
    print(result)
    hist(r, col="darkblue", breaks = 50, main = "F permuted distribution", ylab = "Count"); abline(v = observed, col = "darkorange")
  }
}
```

Testing data:
```{r}
x <- rnorm(100)
y <- 4*x^2+3+10*rnorm(100)
data <- data.frame(x,y)

permutation_lm(data, "x","y","quadratic", "linear", nice_plot=T)
permutation_lm(data, "x","y","quadratic", "cubic", nice_plot=F)
```

